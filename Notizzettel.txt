

// ==========================================

Seminar Modern C++

Guten Morgen

Peter Loos

// ==========================================

a) VS Studio

b) Github

    https://github.com/pelocpp


=============================================

= Fragen:

https://stackoverflow.com/questions/55883162/why-does-stdvector-allow-the-use-of-a-throwable-move-constructor-for-the-type

=============================================

= Was sind meine Erwartungen?

= Welche Sprachen kenne ich noch?

= Was MUSS drin sein?

-- Concepts, Metaprogramming

-- Multithreading

-- Delphi, Rust, Java

// ==========================================

new

:--:  ... 20    // wird freigegeben
:--:  ... A0

:--:  ... 60


-------------------------------------------

emplace ...


-------------------------------------------

class BigData
{
    // data ......
    int m_data;

    BigData () = default;
};

A) BigData bd;

B) BigData bd ();  // Vorsicht: Funktion

C) BigData bd {}; 

=========================================



using namespace std;
std::swap (a, b);

std::cout << "Hello World" << std::endl;


std::operator<< (std::cout, "Hello World");

=========================================

Aufrufbares Objekt

Funktor

Klasse / Objekt, das den Operator () unterstützt.

a()	   Function call

a(1)	       Function call
a(1, 2)	       Function call
a(1, 2, 3)	   Function call

+ Operator:   1 + 2  ===> 2 Parameter

Stelligkeit: Anzahl der Parameter

() Operator:  Beliebig viele

====================

Elision 

Initialisierung:

Initialisierungs-Liste:
=======================

std::initializer_list  ===> Stack

vs.

std::vector:           ===> Heap 

Optimierung:

Vermeide HEAP bei Parameter-Übergabe.

std::initializer_list:

Kein STL-Container:

Leichtgewichtiger Container:

==> begin
==> end
==> size

std::initializer_list und std::vector

        TinyContainer tc2{ 1 };             // TinyContainer::TinyContainer(std::initializer_list<int>)
        TinyContainer tc3(1); 


std::vector<int> vec (10); ==> Size: 10, Werte: 0

std::vector<int> vec {10}; ==> Size: 1,  Wert:  10

=============================================

=============================================

new: ====> delete   // "double delete" NOOOO


Idee:

== OO: Objekte:  

   Konstruktoren:   Erzeugung
   Destruktoren:    Scope  (lokales Objekt)

   Deterministisch

== Zusammenführung:

   Konstruktor: new
   Destruktor: delete

----

Idee: Socket: open, close  // CreateMutex, ReleaseMutex:

   RAII

---

Idee: new / delete Hüllenobjekte // Wrapper

auto_ptr: deprecated

== std::unique_ptr

== std::shared_ptr, std::weak_ptr

Hüllenklassen:

Frage der Strategie:

Frage: Wer ist der Besitzer des Zeigers?

A) Es gibt zu einem Zeitpunkt nur / genau EINEN Besitzer

B) Es kann zu einem Zeitpunkt MEHRERE Besitzer geben

=============================================

std::unique_ptr:

std::shared_ptr:

===========================================

Sind wir glücklich ??????????????  :-)

Der std::shared_ptr funktioniert nicht immer :-(

===========================================
