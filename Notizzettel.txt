

// ==========================================

Seminar Modern C++

Guten Morgen

Peter Loos

// ==========================================

a) VS Studio

b) Github

    https://github.com/pelocpp


=============================================

= Fragen:

https://stackoverflow.com/questions/55883162/why-does-stdvector-allow-the-use-of-a-throwable-move-constructor-for-the-type

= Frage 2:

https://www.cppstories.com/2017/12/weakptr-memory/

= Does Weak_ptr hold memory ???

=============================================

Dienstag:

Generische Lambda Ausdrücke

Konzepte (Concepts)    Da fehlt mir jetzt eine Grundlage ;)

Variant

...

=============================================

Mittwoch:

Var. Templates

Perfect Forwarding

Folding

Range-Based Loop

Placement New: Trennung von Speicherallokation und Objektkonstruktion

Two-Phase Name Lookup

Type Erasure

Buchhandlung

Alle Utility Klassen

std::invoke

Functional Programming


=============================================

Donnerstag:

MT

Modules

CoRoutines

=============================================


= Was sind meine Erwartungen?

= Welche Sprachen kenne ich noch?

= Was MUSS drin sein?

-- Concepts, Metaprogramming

-- Multithreading

-- Delphi, Rust, Java

// ==========================================

new

:--:  ... 20    // wird freigegeben
:--:  ... A0

:--:  ... 60


-------------------------------------------

emplace ...


-------------------------------------------

class BigData
{
    // data ......
    int m_data;

    BigData () = default;
};

A) BigData bd;

B) BigData bd ();  // Vorsicht: Funktion

C) BigData bd {}; 

=========================================



using namespace std;
std::swap (a, b);

std::cout << "Hello World" << std::endl;


std::operator<< (std::cout, "Hello World");

=========================================

Aufrufbares Objekt

Funktor

Klasse / Objekt, das den Operator () unterstützt.

a()	   Function call

a(1)	       Function call
a(1, 2)	       Function call
a(1, 2, 3)	   Function call

+ Operator:   1 + 2  ===> 2 Parameter

Stelligkeit: Anzahl der Parameter

() Operator:  Beliebig viele

====================

Elision 

Initialisierung:

Initialisierungs-Liste:
=======================

std::initializer_list  ===> Stack

vs.

std::vector:           ===> Heap 

Optimierung:

Vermeide HEAP bei Parameter-Übergabe.

std::initializer_list:

Kein STL-Container:

Leichtgewichtiger Container:

==> begin
==> end
==> size

std::initializer_list und std::vector

        TinyContainer tc2{ 1 };             // TinyContainer::TinyContainer(std::initializer_list<int>)
        TinyContainer tc3(1); 


std::vector<int> vec (10); ==> Size: 10, Werte: 0

std::vector<int> vec {10}; ==> Size: 1,  Wert:  10

=============================================

=============================================

new: ====> delete   // "double delete" NOOOO


Idee:

== OO: Objekte:  

   Konstruktoren:   Erzeugung
   Destruktoren:    Scope  (lokales Objekt)

   Deterministisch

== Zusammenführung:

   Konstruktor: new
   Destruktor: delete

----

Idee: Socket: open, close  // CreateMutex, ReleaseMutex:

   RAII

---

Idee: new / delete Hüllenobjekte // Wrapper

auto_ptr: deprecated

== std::unique_ptr

== std::shared_ptr, std::weak_ptr

Hüllenklassen:

Frage der Strategie:

Frage: Wer ist der Besitzer des Zeigers?

A) Es gibt zu einem Zeitpunkt nur / genau EINEN Besitzer

B) Es kann zu einem Zeitpunkt MEHRERE Besitzer geben

=============================================

std::unique_ptr:

std::shared_ptr:

===========================================

Sind wir glücklich ??????????????  :-)

Der std::shared_ptr funktioniert nicht immer :-(

a) Wie funktioniert ???

b) Was ist das Problem des std::shared_ptr 

===========================================

Diskussion:

Verwende ich Smart Pointer ???

IMMER :)

---------------------------------

Go for Unique
Go for Shared

==> Pflegeleicht: Go for Unique

Nachteil: EIN Besitzer.

---------------------------------

Go for Shared:   Mehrere Besitzer.

Wann nehme ich einen Shared_Ptr?
Wann nehme ich einen Weak_Ptr?

"Wenn ich es nur anschauen will"

   ==> Ohhh, Objekt ist gar nicht mehr da :)

"Wenn ich selbst keinen Anspruch auf BESITZ erheben möchte"

==> a) Ich möchte verwalten / NICHT besitzen:

       ==> STL Container ==> Weak_Ptr
       ==> Ohhh, Objekt ist gar nicht mehr da :)



==> a) Ich möchte verwalten / besitzen:

       ==> STL Container ==> shared_Ptr
       ==> Besitz ist garantiert

       ==> Man kann im einem Container Elemente entfernen.
       
       ==> Hoffnung damit: Speicher wird freigegeben:

           Gibt es jemand anderen, der die Rolle des Besitzers
           für sich in Anspruch nimmt ???

     
       ==> Man muss nicht zwingend Sharer-Ptr für KURZE Strecken weiterreichen.

           Man kann auch Raw Zeiger weiterreichen (get): REGEL: KEIN delete.



==============================================================

shared_from_this:

Ab C++ 11

Beispiel:

Datei

Test_SharedFromThis.cpp

Beschreibung:

https://github.com/pelocpp/cpp_design_patterns/blob/master/Patterns/Observer/Resources/Readme.md

==============================================================

CRTP:

Ein Vergleich:

[Collection of Modern C++-Code Examples - Copyright (C) 2019-2024 Peter Loos]

Classical Polymorphism Benchmark:
Pixels: 160000
Time taken: 16.884.734 microseconds

CRTP Benchmark:
Pixels: 160000
Time taken: 16.898.075 microseconds
[Done.]



[Collection of Modern C++-Code Examples - Copyright (C) 2019-2024 Peter Loos]
Classical Polymorphism Benchmark:
Pixels: 160000
Time taken: 1.997.142 microseconds

CRTP Benchmark:
Pixels: 160000
Time taken: 395.044 microseconds
[Done.]

ca. Faktor 5


// ====================================================

Variant    // C - Union.

== Ist ein Container für Werte (Daten) unterschiedlichen Typs.

== Zu einem Zeitpunkt kann nur ein Wert
   eines bestimmten Typs vorhanden sein


Excel:

Zelle // Cell:

Zahlen, Currency, Gleitpunkt, Zeichenketten, Datum


std::variant<int, double, std::string> var{ 123 };

std::any var{ 123 };

// ====================================================

Compiler:  

    template <typename T>   
    auto add(T a, T b)
    {
        return a + b;
    }


Was nehe ich für T ?????

Alles, was sich übersetzen lässt:

===> Verhalten:   Reagierendes Verhalten.

===> Verhalten:   Proaktives Verhalten.

============================================

Konstante / Literal:

123.56f

100_euro;

200_pfund;

300_dollar;

520_gallonen;

0x112211_farbe;   ==> Klasse Color / Objekt

0x112211_rgb;   ==> Klasse Color / Objekt

"123"_gallonen;


"16:47:00"_zeit;

100_euro  =========> Lexikon einer Programmiersprache
                     erweitert;

=========>  Operator:   Literal Operator

            operator ""

Grammatik eines Operators: 

   operator +  LITERAL_IDENTIFIER ( params )